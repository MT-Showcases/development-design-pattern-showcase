[
  {
    "id": "multi-01",
    "title": "User authentication service",
    "category": "multipattern",
    "code": "// Servizio di autenticazione\nclass AuthService {\n  constructor() {\n    if (AuthService.instance) {\n      return AuthService.instance;\n    }\n    this.users = new Map();\n    AuthService.instance = this;\n  }\n\n  register(email, password) {\n    const user = this.createUser(email, password);\n    this.users.set(email, user);\n    return user;\n  }\n\n  createUser(email, password) {\n    if (email.includes('@admin')) {\n      return { email, password, role: 'admin', permissions: ['all'] };\n    }\n    return { email, password, role: 'user', permissions: ['read'] };\n  }\n\n  getUser(email) {\n    return this.users.get(email);\n  }\n}\n\nconst auth1 = new AuthService();\nauth1.register('user@test.com', 'pass123');\nconst auth2 = new AuthService();\nconsole.log(auth1 === auth2); // true",
    "solutionPatterns": ["Singleton", "Factory Method"],
    "solutionExplanation": "Combina <strong>Singleton</strong> (unica istanza di AuthService condivisa) e <strong>Factory Method</strong> (createUser decide il tipo di utente in base all'email). Garantisce un unico punto di gestione autenticazione con creazione flessibile di utenti admin o normali.",
    "solutionSteps": [
      {
        "title": "Singleton check",
        "description": "AuthService controlla e restituisce istanza esistente",
        "code": "if (AuthService.instance) {\n  return AuthService.instance;\n}\nAuthService.instance = this;"
      },
      {
        "title": "Factory logic",
        "description": "createUser crea utente con ruolo basato su email",
        "code": "createUser(email, password) {\n  if (email.includes('@admin')) {\n    return { email, role: 'admin', permissions: ['all'] };\n  }\n  return { email, role: 'user', permissions: ['read'] };\n}"
      },
      {
        "title": "Shared service",
        "description": "auth1 e auth2 sono la stessa istanza",
        "code": "const auth1 = new AuthService();\nconst auth2 = new AuthService();\nconsole.log(auth1 === auth2); // true"
      }
    ],
    "solutionAdvantages": [
      "Autenticazione centralizzata e condivisa",
      "Creazione utenti flessibile per tipo",
      "Stato sincronizzato tra tutti i client"
    ]
  },
  {
    "id": "multi-02",
    "title": "Push notification system",
    "category": "multipattern",
    "code": "// Centro notifiche\nclass NotificationHub {\n  constructor() {\n    this.subscribers = [];\n  }\n\n  subscribe(handler) {\n    this.subscribers.push(handler);\n  }\n\n  notify(event) {\n    this.subscribers.forEach(sub => sub.handle(event));\n  }\n}\n\n// Handler con strategia\nclass NotificationHandler {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  handle(event) {\n    this.strategy.send(event);\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n}\n\n// Strategie di invio\nclass EmailChannel {\n  send(event) {\n    console.log('üìß Email:', event.message);\n  }\n}\n\nclass SMSChannel {\n  send(event) {\n    console.log('üì± SMS:', event.message);\n  }\n}\n\nconst hub = new NotificationHub();\nconst handler1 = new NotificationHandler(new EmailChannel());\nconst handler2 = new NotificationHandler(new SMSChannel());\nhub.subscribe(handler1);\nhub.subscribe(handler2);\nhub.notify({ message: 'Nuovo ordine!' });",
    "solutionPatterns": ["Observer", "Strategy"],
    "solutionExplanation": "Integra <strong>Observer</strong> (NotificationHub notifica tutti i subscriber quando arriva un evento) e <strong>Strategy</strong> (ogni NotificationHandler usa una strategia intercambiabile - email o SMS). Permette broadcast multi-canale con metodi di invio flessibili.",
    "solutionSteps": [
      {
        "title": "Observer hub",
        "description": "NotificationHub mantiene lista e notifica tutti",
        "code": "subscribe(handler) {\n  this.subscribers.push(handler);\n}\nnotify(event) {\n  this.subscribers.forEach(sub => sub.handle(event));\n}"
      },
      {
        "title": "Strategy delegation",
        "description": "Handler delega invio alla strategia",
        "code": "class NotificationHandler {\n  handle(event) {\n    this.strategy.send(event);\n  }\n}"
      },
      {
        "title": "Multi-channel broadcast",
        "description": "Un evento notifica tutti i canali simultaneamente",
        "code": "hub.subscribe(new NotificationHandler(new EmailChannel()));\nhub.subscribe(new NotificationHandler(new SMSChannel()));\nhub.notify({ message: 'Ordine' }); // Email + SMS"
      }
    ],
    "solutionAdvantages": [
      "Broadcast simultaneo a pi√π canali",
      "Canali intercambiabili a runtime",
      "Aggiunta subscriber senza modifiche"
    ]
  },
  {
    "id": "multi-03",
    "title": "Text editor con history",
    "category": "multipattern",
    "code": "// Editor\nclass TextEditor {\n  constructor() {\n    this.content = '';\n    this.history = [];\n  }\n\n  write(text) {\n    const command = new WriteOperation(this, text);\n    command.execute();\n    this.history.push(command);\n  }\n\n  undo() {\n    const command = this.history.pop();\n    if (command) command.undo();\n  }\n\n  getContent() {\n    return this.content;\n  }\n\n  saveSnapshot() {\n    return new EditorSnapshot(this.content);\n  }\n\n  restore(snapshot) {\n    this.content = snapshot.getContent();\n  }\n}\n\n// Command\nclass WriteOperation {\n  constructor(editor, text) {\n    this.editor = editor;\n    this.text = text;\n    this.snapshot = null;\n  }\n\n  execute() {\n    this.snapshot = this.editor.saveSnapshot();\n    this.editor.content += this.text;\n  }\n\n  undo() {\n    this.editor.restore(this.snapshot);\n  }\n}\n\n// Memento\nclass EditorSnapshot {\n  constructor(content) {\n    this.content = content;\n  }\n\n  getContent() {\n    return this.content;\n  }\n}\n\nconst editor = new TextEditor();\neditor.write('Hello ');\neditor.write('World');\nconsole.log(editor.getContent()); // 'Hello World'\neditor.undo();\nconsole.log(editor.getContent()); // 'Hello '",
    "solutionPatterns": ["Command", "Memento"],
    "solutionExplanation": "Combina <strong>Command</strong> (WriteOperation incapsula operazioni di scrittura con execute/undo) e <strong>Memento</strong> (EditorSnapshot salva e ripristina stato dell'editor). Command gestisce esecuzione mentre Memento preserva stati storici per undo.",
    "solutionSteps": [
      {
        "title": "Command con snapshot",
        "description": "WriteOperation salva memento prima di modificare",
        "code": "execute() {\n  this.snapshot = this.editor.saveSnapshot();\n  this.editor.content += this.text;\n}"
      },
      {
        "title": "Memento restore",
        "description": "undo() ripristina snapshot salvato",
        "code": "undo() {\n  this.editor.restore(this.snapshot);\n}"
      },
      {
        "title": "History stack",
        "description": "Editor mantiene stack di command per undo multi-livello",
        "code": "editor.write('Hello');\neditor.write('World');\neditor.undo(); // Ripristina snapshot"
      }
    ],
    "solutionAdvantages": [
      "Undo multi-livello senza contaminare editor",
      "Snapshot immutabili dello stato",
      "Operazioni reversibili e tracciabili"
    ]
  },
  {
    "id": "multi-04",
    "title": "Smart database query system",
    "category": "multipattern",
    "code": "// Database reale\nclass DatabaseService {\n  query(sql) {\n    console.log('üîç Query DB:', sql);\n    return { data: `Result for ${sql}` };\n  }\n}\n\n// Proxy con cache\nclass QueryCache {\n  constructor() {\n    this.db = new DatabaseService();\n    this.cache = new Map();\n  }\n\n  query(sql) {\n    if (this.cache.has(sql)) {\n      console.log('üíæ Cache hit');\n      return this.cache.get(sql);\n    }\n    \n    const result = this.db.query(sql);\n    this.cache.set(sql, result);\n    return result;\n  }\n\n  clearCache() {\n    this.cache.clear();\n  }\n}\n\n// Builder per query\nclass QueryBuilder {\n  constructor(cache) {\n    this.cache = cache;\n    this.sql = '';\n  }\n\n  select(fields) {\n    this.sql = `SELECT ${fields}`;\n    return this;\n  }\n\n  from(table) {\n    this.sql += ` FROM ${table}`;\n    return this;\n  }\n\n  where(condition) {\n    this.sql += ` WHERE ${condition}`;\n    return this;\n  }\n\n  execute() {\n    return this.cache.query(this.sql);\n  }\n}\n\nconst cache = new QueryCache();\nconst query = new QueryBuilder(cache);\nquery.select('*').from('users').where('id=1').execute();\nquery.select('*').from('users').where('id=1').execute(); // Cache hit",
    "solutionPatterns": ["Proxy", "Builder"],
    "solutionExplanation": "Integra <strong>Proxy</strong> (QueryCache intercetta query aggiungendo layer di cache) e <strong>Builder</strong> (QueryBuilder costruisce SQL passo dopo passo con interfaccia fluida). Ottimizza performance con cache trasparente e query leggibili.",
    "solutionSteps": [
      {
        "title": "Proxy con cache",
        "description": "QueryCache controlla cache prima di chiamare DB",
        "code": "query(sql) {\n  if (this.cache.has(sql)) return this.cache.get(sql);\n  const result = this.db.query(sql);\n  this.cache.set(sql, result);\n}"
      },
      {
        "title": "Builder fluente",
        "description": "QueryBuilder costruisce SQL con chaining",
        "code": "select(fields) {\n  this.sql = `SELECT ${fields}`;\n  return this;\n}\nfrom(table) { this.sql += ` FROM ${table}`; return this; }"
      },
      {
        "title": "Composizione",
        "description": "Builder usa proxy per esecuzione con cache",
        "code": "query.select('*').from('users').where('id=1').execute();\n// Prima volta: DB ‚Üí cache\n// Seconda volta: cache hit"
      }
    ],
    "solutionAdvantages": [
      "Cache trasparente per performance",
      "Query SQL leggibili e type-safe",
      "Chaining fluido per costruzione query"
    ]
  },
  {
    "id": "multi-05",
    "title": "Advanced logging framework",
    "category": "multipattern",
    "code": "// Logger base\nclass Logger {\n  log(message) {\n    console.log(message);\n  }\n}\n\n// Decorator timestamp\nclass TimestampLogger {\n  constructor(logger) {\n    this.logger = logger;\n  }\n\n  log(message) {\n    const timestamp = new Date().toISOString();\n    this.logger.log(`[${timestamp}] ${message}`);\n  }\n}\n\n// Decorator livello\nclass LevelLogger {\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n\n  log(message) {\n    this.logger.log(`[${this.level}] ${message}`);\n  }\n}\n\n// Composite per multi-output\nclass MultiLogger {\n  constructor() {\n    this.loggers = [];\n  }\n\n  add(logger) {\n    this.loggers.push(logger);\n  }\n\n  log(message) {\n    this.loggers.forEach(logger => logger.log(message));\n  }\n}\n\nconst fileLogger = new LevelLogger(new TimestampLogger(new Logger()), 'INFO');\nconst consoleLogger = new LevelLogger(new Logger(), 'DEBUG');\n\nconst multi = new MultiLogger();\nmulti.add(fileLogger);\nmulti.add(consoleLogger);\nmulti.log('App started');",
    "solutionPatterns": ["Decorator", "Composite"],
    "solutionExplanation": "Combina <strong>Decorator</strong> (TimestampLogger e LevelLogger aggiungono funzionalit√† senza modificare Logger base) e <strong>Composite</strong> (MultiLogger gestisce multipli logger come uno solo). Permette logging flessibile con output gerarchici e decorazioni multiple.",
    "solutionSteps": [
      {
        "title": "Decorator chain",
        "description": "Decorator wrappano logger aggiungendo timestamp e livello",
        "code": "const enhanced = new LevelLogger(\n  new TimestampLogger(new Logger()),\n  'INFO'\n);"
      },
      {
        "title": "Composite aggregation",
        "description": "MultiLogger raccoglie e coordina pi√π logger",
        "code": "class MultiLogger {\n  log(message) {\n    this.loggers.forEach(logger => logger.log(message));\n  }\n}"
      },
      {
        "title": "Hierarchical output",
        "description": "Un log si propaga a tutti i logger registrati",
        "code": "multi.add(fileLogger);\nmulti.add(consoleLogger);\nmulti.log('Message'); // Output a entrambi"
      }
    ],
    "solutionAdvantages": [
      "Funzionalit√† aggiungibili dinamicamente",
      "Log simultaneo su pi√π output",
      "Decoratori componibili (timestamp + level)"
    ]
  },
  {
    "id": "multi-06",
    "title": "E-commerce shopping cart",
    "category": "multipattern",
    "code": "// Carrello con stati e notifiche\nclass ShoppingCart {\n  constructor() {\n    this.items = [];\n    this.observers = [];\n    this.state = new EmptyCart(this);\n  }\n\n  addItem(item) {\n    this.items.push(item);\n    this.state.addItem();\n    this.notifyObservers();\n  }\n\n  setState(state) {\n    this.state = state;\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyObservers() {\n    this.observers.forEach(obs => obs.update(this));\n  }\n\n  checkout(paymentStrategy) {\n    this.state.checkout(paymentStrategy);\n  }\n}\n\n// Stati\nclass EmptyCart {\n  constructor(cart) { this.cart = cart; }\n  addItem() { this.cart.setState(new ActiveCart(this.cart)); }\n  checkout() { console.log('‚ùå Carrello vuoto'); }\n}\n\nclass ActiveCart {\n  constructor(cart) { this.cart = cart; }\n  addItem() {}\n  checkout(strategy) {\n    const total = this.cart.items.reduce((sum, item) => sum + item.price, 0);\n    strategy.pay(total);\n    this.cart.setState(new PaidCart(this.cart));\n  }\n}\n\nclass PaidCart {\n  constructor(cart) { this.cart = cart; }\n  addItem() { console.log('‚ùå Ordine gi√† confermato'); }\n  checkout() { console.log('‚ùå Gi√† pagato'); }\n}\n\n// Strategie pagamento\nclass CreditCard {\n  pay(amount) { console.log(`üí≥ Pagato ‚Ç¨${amount}`); }\n}\n\n// Observer\nclass CartDisplay {\n  update(cart) { console.log(`üõí ${cart.items.length} items`); }\n}\n\nconst cart = new ShoppingCart();\ncart.subscribe(new CartDisplay());\ncart.addItem({ name: 'Book', price: 15 });\ncart.checkout(new CreditCard());",
    "solutionPatterns": ["Observer", "State", "Strategy"],
    "solutionExplanation": "Integra <strong>Observer</strong> (notifica CartDisplay quando cambia carrello), <strong>State</strong> (gestisce transizioni Empty‚ÜíActive‚ÜíPaid) e <strong>Strategy</strong> (metodo pagamento intercambiabile). Sistema completo con gestione stati, notifiche UI e pagamenti flessibili.",
    "solutionSteps": [
      {
        "title": "State transitions",
        "description": "addItem e checkout cambiano stato del carrello",
        "code": "class EmptyCart {\n  addItem() {\n    this.cart.setState(new ActiveCart(this.cart));\n  }\n}"
      },
      {
        "title": "Observer notification",
        "description": "Ogni modifica notifica observer (UI update)",
        "code": "addItem(item) {\n  this.items.push(item);\n  this.state.addItem();\n  this.notifyObservers(); // Update UI\n}"
      },
      {
        "title": "Strategy payment",
        "description": "checkout delega pagamento alla strategia",
        "code": "checkout(strategy) {\n  const total = this.cart.items.reduce(...);\n  strategy.pay(total); // CreditCard, PayPal, etc.\n}"
      }
    ],
    "solutionAdvantages": [
      "UI sincronizzata automaticamente (Observer)",
      "Workflow carrello robusto (State)",
      "Metodi pagamento flessibili (Strategy)"
    ]
  },
  {
    "id": "multi-07",
    "title": "UI component framework",
    "category": "multipattern",
    "code": "// Componente base\nclass Component {\n  render() {}\n}\n\nclass Button extends Component {\n  constructor(text) {\n    super();\n    this.text = text;\n  }\n  render() { return `<button>${this.text}</button>`; }\n}\n\n// Composite container\nclass Container extends Component {\n  constructor() {\n    super();\n    this.children = [];\n  }\n  add(component) { this.children.push(component); }\n  render() {\n    return `<div>${this.children.map(c => c.render()).join('')}</div>`;\n  }\n}\n\n// Decorator tema\nclass ThemedComponent extends Component {\n  constructor(component, theme) {\n    super();\n    this.component = component;\n    this.theme = theme;\n  }\n  render() {\n    return `<div class=\"${this.theme}\">${this.component.render()}</div>`;\n  }\n}\n\n// Proxy lazy loading\nclass LazyComponent extends Component {\n  constructor(componentFn) {\n    super();\n    this.componentFn = componentFn;\n    this.component = null;\n  }\n  render() {\n    if (!this.component) {\n      console.log('‚è≥ Caricamento lazy...');\n      this.component = this.componentFn();\n    }\n    return this.component.render();\n  }\n}\n\nconst page = new Container();\npage.add(new ThemedComponent(new Button('Click'), 'dark'));\npage.add(new LazyComponent(() => new Button('Lazy')));\nconsole.log(page.render());",
    "solutionPatterns": ["Composite", "Decorator", "Proxy"],
    "solutionExplanation": "Combina <strong>Composite</strong> (Container gestisce albero di componenti), <strong>Decorator</strong> (ThemedComponent aggiunge stili senza modificare componente) e <strong>Proxy</strong> (LazyComponent carica on-demand). Pattern fondamentali di framework UI moderni come React.",
    "solutionSteps": [
      {
        "title": "Composite tree",
        "description": "Container gestisce figli e render ricorsivo",
        "code": "class Container extends Component {\n  render() {\n    return `<div>${this.children.map(c => c.render()).join('')}</div>`;\n  }\n}"
      },
      {
        "title": "Decorator wrapping",
        "description": "ThemedComponent wrappa e aggiunge classe CSS",
        "code": "class ThemedComponent {\n  render() {\n    return `<div class=\"${this.theme}\">${this.component.render()}</div>`;\n  }\n}"
      },
      {
        "title": "Proxy lazy load",
        "description": "LazyComponent ritarda creazione fino al primo render",
        "code": "render() {\n  if (!this.component) {\n    this.component = this.componentFn();\n  }\n  return this.component.render();\n}"
      }
    ],
    "solutionAdvantages": [
      "Albero componenti flessibile (Composite)",
      "Decorazioni dinamiche senza modifiche (Decorator)",
      "Lazy loading per performance (Proxy)"
    ]
  },
  {
    "id": "multi-08",
    "title": "Application configuration manager",
    "category": "multipattern",
    "code": "// Configurazione singleton\nclass Config {\n  constructor() {\n    if (Config.instance) {\n      return Config.instance;\n    }\n    this.settings = {};\n    this.prototypes = {};\n    Config.instance = this;\n  }\n\n  set(key, value) {\n    this.settings[key] = value;\n  }\n\n  get(key) {\n    return this.settings[key];\n  }\n\n  registerPrototype(name, obj) {\n    this.prototypes[name] = obj;\n  }\n\n  create(name) {\n    const proto = this.prototypes[name];\n    if (!proto) return null;\n    return { ...proto };\n  }\n}\n\n// Builder per configurazione\nclass ConfigBuilder {\n  constructor() {\n    this.config = new Config();\n  }\n\n  setDatabase(db) {\n    this.config.set('database', db);\n    return this;\n  }\n\n  setPort(port) {\n    this.config.set('port', port);\n    return this;\n  }\n\n  setCache(cache) {\n    this.config.set('cache', cache);\n    return this;\n  }\n\n  build() {\n    return this.config;\n  }\n}\n\nconst config = new ConfigBuilder()\n  .setDatabase('mongodb://localhost')\n  .setPort(3000)\n  .setCache(true)\n  .build();\n\nconfig.registerPrototype('user', { role: 'guest', permissions: [] });\nconst user1 = config.create('user');\nconst user2 = config.create('user');",
    "solutionPatterns": ["Singleton", "Builder", "Prototype"],
    "solutionExplanation": "Integra <strong>Singleton</strong> (una sola istanza Config condivisa), <strong>Builder</strong> (ConfigBuilder costruisce configurazione passo dopo passo con interfaccia fluida) e <strong>Prototype</strong> (clonazione template di oggetti registrati). Sistema completo per configurazione centralizzata e flessibile.",
    "solutionSteps": [
      {
        "title": "Singleton instance",
        "description": "Config garantisce istanza unica condivisa",
        "code": "if (Config.instance) {\n  return Config.instance;\n}\nConfig.instance = this;"
      },
      {
        "title": "Builder chaining",
        "description": "ConfigBuilder costruisce con metodi fluenti",
        "code": "new ConfigBuilder()\n  .setDatabase('mongodb://localhost')\n  .setPort(3000)\n  .setCache(true)\n  .build()"
      },
      {
        "title": "Prototype cloning",
        "description": "Config clona template registrati per nuovi oggetti",
        "code": "config.registerPrototype('user', { role: 'guest' });\nconst user1 = config.create('user'); // Clone"
      }
    ],
    "solutionAdvantages": [
      "Configurazione centralizzata (Singleton)",
      "Setup leggibile e type-safe (Builder)",
      "Template riutilizzabili (Prototype)"
    ]
  },
  {
    "id": "multi-09",
    "title": "Data processing pipeline",
    "category": "multipattern",
    "code": "// Processore con chain\nclass DataProcessor {\n  constructor() {\n    this.chain = null;\n  }\n\n  setChain(handler) {\n    this.chain = handler;\n  }\n\n  process(data) {\n    if (this.chain) {\n      return this.chain.handle(data);\n    }\n    return data;\n  }\n}\n\n// Handler base\nclass Handler {\n  constructor() {\n    this.next = null;\n  }\n\n  setNext(handler) {\n    this.next = handler;\n    return handler;\n  }\n\n  handle(data) {\n    if (this.next) {\n      return this.next.handle(data);\n    }\n    return data;\n  }\n}\n\n// Validation handler\nclass ValidationHandler extends Handler {\n  handle(data) {\n    console.log('‚úì Validazione');\n    if (!data || data.length === 0) throw new Error('Invalid data');\n    return super.handle(data);\n  }\n}\n\n// Transform con strategy\nclass TransformHandler extends Handler {\n  constructor(strategy) {\n    super();\n    this.strategy = strategy;\n  }\n\n  handle(data) {\n    console.log('‚öôÔ∏è Trasformazione');\n    const transformed = this.strategy.transform(data);\n    return super.handle(transformed);\n  }\n}\n\n// Strategie\nclass UppercaseStrategy {\n  transform(data) { return data.toUpperCase(); }\n}\n\nclass ReverseStrategy {\n  transform(data) { return data.split('').reverse().join(''); }\n}\n\nconst processor = new DataProcessor();\nconst validation = new ValidationHandler();\nconst transform = new TransformHandler(new UppercaseStrategy());\n\nvalidation.setNext(transform);\nprocessor.setChain(validation);\n\nconsole.log(processor.process('hello')); // HELLO",
    "solutionPatterns": ["Chain of Responsibility", "Strategy"],
    "solutionExplanation": "Combina <strong>Chain of Responsibility</strong> (catena di handler processa dati sequenzialmente) e <strong>Strategy</strong> (algoritmi di trasformazione intercambiabili). Crea pipeline flessibile per elaborazione dati multi-step con validazione e trasformazioni customizzabili.",
    "solutionSteps": [
      {
        "title": "Chain setup",
        "description": "Handler collegati tramite setNext formano pipeline",
        "code": "const validation = new ValidationHandler();\nconst transform = new TransformHandler(new UppercaseStrategy());\nvalidation.setNext(transform);"
      },
      {
        "title": "Strategy injection",
        "description": "TransformHandler usa strategy per algoritmo",
        "code": "class TransformHandler {\n  handle(data) {\n    const transformed = this.strategy.transform(data);\n    return super.handle(transformed);\n  }\n}"
      },
      {
        "title": "Pipeline execution",
        "description": "Dati fluiscono attraverso chain con trasformazioni",
        "code": "processor.setChain(validation);\nprocessor.process('hello');\n// ‚Üí Validation ‚Üí Transform (uppercase) ‚Üí 'HELLO'"
      }
    ],
    "solutionAdvantages": [
      "Pipeline configurabile e estendibile",
      "Algoritmi trasformazione intercambiabili",
      "Ordine processing flessibile"
    ]
  },
  {
    "id": "multi-10",
    "title": "Business reporting system",
    "category": "multipattern",
    "code": "// Template per report\nclass ReportGenerator {\n  generateReport() {\n    this.collectData();\n    this.formatData();\n    this.addHeader();\n    this.addFooter();\n    if (this.includeCharts()) {\n      this.generateCharts();\n    }\n    return this.export();\n  }\n\n  collectData() { console.log('üìä Raccolta dati'); }\n  formatData() {}\n  addHeader() {}\n  addFooter() {}\n  includeCharts() { return false; }\n  generateCharts() {}\n  export() {}\n}\n\n// Report concreti\nclass PDFReport extends ReportGenerator {\n  formatData() { console.log('üìÑ Formattazione PDF'); }\n  export() { return 'report.pdf'; }\n}\n\nclass ExcelReport extends ReportGenerator {\n  formatData() { console.log('üìó Formattazione Excel'); }\n  includeCharts() { return true; }\n  generateCharts() { console.log('üìà Grafici Excel'); }\n  export() { return 'report.xlsx'; }\n}\n\n// Facade per sistema complesso\nclass ReportingSystem {\n  constructor() {\n    this.database = { query: () => ['data1', 'data2'] };\n    this.emailService = { send: (file) => console.log(`üìß Invio ${file}`) };\n    this.storage = { save: (file) => console.log(`üíæ Salvataggio ${file}`) };\n  }\n\n  generateAndSendReport(type, recipient) {\n    let report;\n    if (type === 'pdf') {\n      report = new PDFReport();\n    } else {\n      report = new ExcelReport();\n    }\n\n    const file = report.generateReport();\n    this.storage.save(file);\n    this.emailService.send(file);\n    return file;\n  }\n}\n\nconst system = new ReportingSystem();\nsystem.generateAndSendReport('excel', 'manager@company.com');",
    "solutionPatterns": ["Template Method", "Facade"],
    "solutionExplanation": "Unisce <strong>Template Method</strong> (ReportGenerator definisce algoritmo con step customizzabili - collectData, formatData, export) e <strong>Facade</strong> (ReportingSystem semplifica interazione con database, storage, email). Genera report con struttura fissa ma dettagli variabili, nascondendo complessit√† dietro interfaccia semplice.",
    "solutionSteps": [
      {
        "title": "Template algorithm",
        "description": "generateReport definisce sequenza fissa di step",
        "code": "generateReport() {\n  this.collectData();\n  this.formatData();\n  this.addHeader();\n  if (this.includeCharts()) this.generateCharts();\n  return this.export();\n}"
      },
      {
        "title": "Concrete implementations",
        "description": "PDFReport ed ExcelReport customizzano solo step variabili",
        "code": "class ExcelReport extends ReportGenerator {\n  formatData() { console.log('Excel format'); }\n  includeCharts() { return true; }\n}"
      },
      {
        "title": "Facade simplification",
        "description": "ReportingSystem nasconde complessit√† multi-servizio",
        "code": "generateAndSendReport(type) {\n  const report = type === 'pdf' ? new PDFReport() : new ExcelReport();\n  const file = report.generateReport();\n  this.storage.save(file);\n  this.emailService.send(file);\n}"
      }
    ],
    "solutionAdvantages": [
      "Algoritmo report riutilizzabile (Template)",
      "Interfaccia semplice per sistema complesso (Facade)",
      "Customizzazione controllata dei report"
    ]
  }
]
