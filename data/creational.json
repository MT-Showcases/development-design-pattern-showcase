[
  {
    "id": "creational-01",
    "title": "Sistema di notifiche",
    "category": "creational",
    "code": "// Classe per notifiche email\nclass EmailNotifier {\n  send(msg) {\n    console.log(`ðŸ“§ Email: ${msg}`);\n  }\n}\n\n// Classe per notifiche SMS\nclass SMSNotifier {\n  send(msg) {\n    console.log(`ðŸ“± SMS: ${msg}`);\n  }\n}\n\n// Factory che crea il notificatore giusto\nfunction createNotifier(type) {\n  if (type === 'email') return new EmailNotifier();\n  if (type === 'sms') return new SMSNotifier();\n}\n\nconst notifier = createNotifier('email');\nnotifier.send('Benvenuto!');",
    "solutionExplanation": "Il <strong>Factory Method</strong> centralizza la creazione di oggetti simili che condividono la stessa interfaccia. Invece di istanziare direttamente le classi concrete, deleghiamo la decisione a una funzione factory che sceglie quale oggetto creare in base ai parametri ricevuti.",
    "solutionSteps": [
      {
        "title": "Definizione prodotti",
        "description": "Due classi con la stessa interfaccia (metodo `send`)",
        "code": "class EmailNotifier {\n  send(msg) {\n    console.log(`ðŸ“§ Email: ${msg}`);\n  }\n}\n\nclass SMSNotifier {\n  send(msg) {\n    console.log(`ðŸ“± SMS: ${msg}`);\n  }\n}"
      },
      {
        "title": "Factory function",
        "description": "Un'unica funzione decide quale oggetto creare in base al parametro",
        "code": "function createNotifier(type) {\n  if (type === 'email') return new EmailNotifier();\n  if (type === 'sms') return new SMSNotifier();\n}"
      },
      {
        "title": "Utilizzo",
        "description": "Il client non conosce la classe concreta, usa solo l'interfaccia comune",
        "code": "const notifier = createNotifier('email');\nnotifier.send('Benvenuto!');"
      }
    ],
    "solutionAdvantages": [
      "Centralizza la logica di istanziazione",
      "Facilita l'aggiunta di nuovi tipi",
      "Disaccoppia il codice client dalle classi concrete"
    ],
    "solutionPatterns": [
      "Factory Method"
    ]
  },
  {
    "id": "creational-02",
    "title": "Creazione veicoli",
    "category": "creational",
    "code": "// Veicoli diversi\nclass Car {\n  constructor(model) {\n    this.type = 'car';\n    this.model = model;\n  }\n}\n\nclass Motorcycle {\n  constructor(model) {\n    this.type = 'motorcycle';\n    this.model = model;\n  }\n}\n\n// Factory che decide quale istanziare\nfunction createVehicle(type, model) {\n  if (type === 'car') return new Car(model);\n  if (type === 'motorcycle') return new Motorcycle(model);\n  throw new Error('Tipo sconosciuto');\n}\n\nconst myCar = createVehicle('car', 'Sedan');\nconst myBike = createVehicle('motorcycle', 'Sport');",
    "solutionExplanation": "Il <strong>Factory Method</strong> incapsula la logica di istanziazione",
    "solutionPatterns": [
      "Factory Method"
    ],
    "solutionSteps": [
      {
        "title": "Classi concrete",
        "description": "Ogni veicolo ha la sua classe",
        "code": "class Car { constructor(model) {...} }\nclass Motorcycle { constructor(model) {...} }"
      },
      {
        "title": "Factory con switch",
        "description": "Scelta basata sul parametro `type`",
        "code": "function createVehicle(type, model) {\n  if (type === 'car') return new Car(model);\n  if (type === 'motorcycle') return new Motorcycle(model);\n}"
      },
      {
        "title": "Creazione semplificata",
        "description": "Il client non usa `new` direttamente",
        "code": "const myCar = createVehicle('car', 'Sedan');"
      }
    ],
    "solutionAdvantages": [
      "Aggiungere nuovi tipi non richiede modifiche al client",
      "validazione centralizzata",
      "estendibilitÃ  migliorata."
    ]
  },
  {
    "id": "creational-03",
    "title": "Payment processor",
    "category": "creational",
    "code": "// Processori di pagamento\nclass StripeProcessor {\n  process(amount) {\n    console.log(`Stripe: â‚¬${amount}`);\n  }\n}\n\nclass PayPalProcessor {\n  process(amount) {\n    console.log(`PayPal: â‚¬${amount}`);\n  }\n}\n\n// Factory per scegliere il processore\nfunction createPaymentProcessor(type) {\n  if (type === 'stripe') return new StripeProcessor();\n  if (type === 'paypal') return new PayPalProcessor();\n  throw new Error('Processore non supportato');\n}\n\nconst processor = createPaymentProcessor('stripe');\nprocessor.process(99.99);",
    "solutionExplanation": "Il <strong>Factory Method</strong> astrae provider di pagamento",
    "solutionPatterns": [
      "Factory Method"
    ],
    "solutionSteps": [
      {
        "title": "Implementazioni specifiche",
        "description": "Ogni provider ha la sua logica",
        "code": "class StripeProcessor {\n  process(amount) { console.log(`Stripe: â‚¬${amount}`); }\n}"
      },
      {
        "title": "Factory function",
        "description": "Centralizza la selezione del provider",
        "code": "function createPaymentProcessor(type) {\n  if (type === 'stripe') return new StripeProcessor();\n  ...\n}"
      },
      {
        "title": "Utilizzo trasparente",
        "description": "Cambio provider senza modificare il codice client",
        "code": "const processor = createPaymentProcessor('stripe');\nprocessor.process(99.99);"
      }
    ],
    "solutionAdvantages": [
      "Multi-provider strategy",
      "facile A/B testing",
      "compliance regionale semplificata."
    ]
  },
  {
    "id": "creational-04",
    "title": "Logger con livelli",
    "category": "creational",
    "code": "// Logger diversi per livello\nclass DebugLogger {\n  log(msg) {\n    console.log(`[DEBUG] ${msg}`);\n  }\n}\n\nclass ErrorLogger {\n  log(msg) {\n    console.error(`[ERROR] ${msg}`);\n  }\n}\n\n// Factory che crea il logger giusto\nfunction createLogger(level) {\n  if (level === 'debug') return new DebugLogger();\n  if (level === 'error') return new ErrorLogger();\n  return new DebugLogger();\n}\n\nconst logger = createLogger('debug');\nlogger.log('App started');",
    "solutionExplanation": "Il <strong>Factory Method</strong> crea logger con livelli diversi",
    "solutionPatterns": [
      "Factory Method"
    ],
    "solutionSteps": [
      {
        "title": "Logger specializzati",
        "description": "Ogni logger ha formato e output diverso",
        "code": "class DebugLogger { log(msg) { console.log(`[DEBUG] ${msg}`); } }\nclass ErrorLogger { log(msg) { console.error(`[ERROR] ${msg}`); } }"
      },
      {
        "title": "Factory basata su livello",
        "description": "Scelta automatica in base all'environment",
        "code": "function createLogger(level) {\n  if (level === 'debug') return new DebugLogger();\n  ...\n}"
      },
      {
        "title": "Configurazione centralizzata",
        "description": "Cambio globale senza toccare il codice",
        "code": "const logger = createLogger(process.env.LOG_LEVEL);"
      }
    ],
    "solutionAdvantages": [
      "Formato consistente",
      "configurazione environment-based",
      "facile estensione con nuovi livelli."
    ]
  },
  {
    "id": "creational-05",
    "title": "Validatori di form",
    "category": "creational",
    "code": "// Validatori specifici\nclass EmailValidator {\n  validate(value) {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n  }\n}\n\nclass PhoneValidator {\n  validate(value) {\n    return /^\\d{10}$/.test(value);\n  }\n}\n\n// Factory per creare validatori\nfunction createValidator(type) {\n  if (type === 'email') return new EmailValidator();\n  if (type === 'phone') return new PhoneValidator();\n  return null;\n}\n\nconst validator = createValidator('email');\nconsole.log(validator.validate('test@example.com'));",
    "solutionExplanation": "Il <strong>Factory Method</strong> crea validatori per tipi di input",
    "solutionPatterns": [
      "Factory Method"
    ],
    "solutionSteps": [
      {
        "title": "Validatori con regex",
        "description": "Ogni validatore ha la sua logica",
        "code": "class EmailValidator {\n  validate(value) { return /regex/.test(value); }\n}"
      },
      {
        "title": "Factory function",
        "description": "Crea il validatore appropriato al campo",
        "code": "function createValidator(type) {\n  if (type === 'email') return new EmailValidator();\n  ...\n}"
      },
      {
        "title": "Validazione dinamica",
        "description": "Form validation automatica",
        "code": "const validator = createValidator(field.type);\nvalidator.validate(value);"
      }
    ],
    "solutionAdvantages": [
      "Aggiunta facile di nuove regole",
      "riutilizzo dei validatori",
      "testabilitÃ  migliorata."
    ]
  },
  {
    "id": "creational-06",
    "title": "Cache applicazione",
    "category": "creational",
    "code": "// Cache singleton\nclass Cache {\n  constructor() {\n    if (Cache.instance) {\n      return Cache.instance;\n    }\n    this.data = new Map();\n    Cache.instance = this;\n  }\n\n  set(key, value) {\n    this.data.set(key, value);\n  }\n\n  get(key) {\n    return this.data.get(key);\n  }\n}\n\nconst cache1 = new Cache();\ncache1.set('user', { name: 'Mario' });\n\nconst cache2 = new Cache();\nconsole.log(cache2.get('user')); // { name: 'Mario' }",
    "solutionExplanation": "Il <strong>Singleton</strong> un'unica istanza condivisa",
    "solutionPatterns": [
      "Singleton"
    ],
    "solutionSteps": [
      {
        "title": "Controllo istanza",
        "description": "Se esiste giÃ , ritorna quella",
        "code": "if (Cache.instance) {\n  return Cache.instance;\n}"
      },
      {
        "title": "Creazione unica",
        "description": "Salva l'istanza in una proprietÃ  statica",
        "code": "this.data = new Map();\nCache.instance = this;"
      },
      {
        "title": "Condivisione",
        "description": "Tutte le `new Cache()` ritornano la stessa istanza",
        "code": "const cache1 = new Cache();\nconst cache2 = new Cache();\nconsole.log(cache1 === cache2); // true"
      }
    ],
    "solutionAdvantages": [
      "Dati condivisi",
      "memoria ottimizzata",
      "stato centralizzato."
    ]
  },
  {
    "id": "creational-07",
    "title": "Logger applicazione",
    "category": "creational",
    "code": "// Logger unico\nclass Logger {\n  constructor() {\n    if (Logger.instance) {\n      return Logger.instance;\n    }\n    this.logs = [];\n    Logger.instance = this;\n  }\n\n  log(msg) {\n    this.logs.push({ msg, time: Date.now() });\n    console.log(msg);\n  }\n\n  getLogs() {\n    return this.logs;\n  }\n}\n\nconst logger1 = new Logger();\nlogger1.log('Start');\n\nconst logger2 = new Logger();\nconsole.log(logger2.getLogs()); // [{ msg: 'Start', ... }]",
    "solutionExplanation": "Il <strong>Singleton</strong> logger centralizzato",
    "solutionPatterns": [
      "Singleton"
    ],
    "solutionSteps": [
      {
        "title": "Istanza unica",
        "description": "Ritorna sempre la stessa istanza",
        "code": "if (Logger.instance) {\n  return Logger.instance;\n}"
      },
      {
        "title": "Array condiviso",
        "description": "Tutti i log finiscono nello stesso array",
        "code": "this.logs = [];\nLogger.instance = this;"
      },
      {
        "title": "Accesso globale",
        "description": "Log accessibili da qualsiasi punto",
        "code": "const logger1 = new Logger();\nlogger1.log('Start');\nconst logger2 = new Logger();\nlogger2.getLogs(); // Vede i log di logger1"
      }
    ],
    "solutionAdvantages": [
      "Log centralizzati",
      "debugging facilitato",
      "history completa."
    ]
  },
  {
    "id": "creational-08",
    "title": "Connessione database",
    "category": "creational",
    "code": "// Database connection singleton\nclass DatabaseConnection {\n  constructor() {\n    if (DatabaseConnection.instance) {\n      return DatabaseConnection.instance;\n    }\n    this.connected = false;\n    DatabaseConnection.instance = this;\n  }\n\n  connect() {\n    if (!this.connected) {\n      console.log('Connecting to database...');\n      this.connected = true;\n    }\n  }\n\n  query(sql) {\n    return `Executing: ${sql}`;\n  }\n}\n\nconst db1 = new DatabaseConnection();\ndb1.connect();\n\nconst db2 = new DatabaseConnection();\nconsole.log(db1 === db2); // true",
    "solutionExplanation": "Il <strong>Singleton</strong> connessione unica al database",
    "solutionPatterns": [
      "Singleton"
    ],
    "solutionSteps": [
      {
        "title": "Controllo istanza",
        "description": "Evita connessioni multiple",
        "code": "if (DatabaseConnection.instance) {\n  return DatabaseConnection.instance;\n}"
      },
      {
        "title": "Connessione singola",
        "description": "Una sola connessione attiva",
        "code": "this.connected = false;\nDatabaseConnection.instance = this;"
      },
      {
        "title": "Riutilizzo",
        "description": "Risparmio di risorse",
        "code": "const db1 = new DatabaseConnection();\nconst db2 = new DatabaseConnection();\nconsole.log(db1 === db2); // true"
      }
    ],
    "solutionAdvantages": [
      "Previene connection pool overflow",
      "ottimizza risorse",
      "garantisce consistenza transazioni."
    ]
  },
  {
    "id": "creational-09",
    "title": "Configurazione app",
    "category": "creational",
    "code": "// Config singleton\nclass AppConfig {\n  constructor() {\n    if (AppConfig.instance) {\n      return AppConfig.instance;\n    }\n    this.settings = {\n      theme: 'light',\n      lang: 'it'\n    };\n    AppConfig.instance = this;\n  }\n\n  get(key) {\n    return this.settings[key];\n  }\n\n  set(key, value) {\n    this.settings[key] = value;\n  }\n}\n\nconst config1 = new AppConfig();\nconfig1.set('theme', 'dark');\n\nconst config2 = new AppConfig();\nconsole.log(config2.get('theme')); // 'dark'",
    "solutionExplanation": "Il <strong>Singleton</strong> configurazione centralizzata",
    "solutionPatterns": [
      "Singleton"
    ],
    "solutionSteps": [
      {
        "title": "Istanza unica",
        "description": "Una sola config per tutta l'app",
        "code": "if (AppConfig.instance) {\n  return AppConfig.instance;\n}"
      },
      {
        "title": "Settings condivise",
        "description": "Impostazioni globali",
        "code": "this.settings = { theme: 'light', lang: 'it' };\nAppConfig.instance = this;"
      },
      {
        "title": "Sincronizzazione",
        "description": "Cambi visibili ovunque",
        "code": "config1.set('theme', 'dark');\nconfig2.get('theme'); // 'dark'"
      }
    ],
    "solutionAdvantages": [
      "Settings sincronizzate",
      "configurazione globale",
      "no conflitti."
    ]
  },
  {
    "id": "creational-10",
    "title": "Event registry",
    "category": "creational",
    "code": "// Event bus singleton\nclass EventRegistry {\n  constructor() {\n    if (EventRegistry.instance) {\n      return EventRegistry.instance;\n    }\n    this.listeners = {};\n    EventRegistry.instance = this;\n  }\n\n  on(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n\n  emit(event, data) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach(cb => cb(data));\n    }\n  }\n}\n\nconst events = new EventRegistry();\nevents.on('userLogin', () => console.log('User logged in'));",
    "solutionExplanation": "Il <strong>Singleton</strong> event bus globale",
    "solutionPatterns": [
      "Singleton"
    ],
    "solutionSteps": [
      {
        "title": "Registry unico",
        "description": "Un solo event bus per l'app",
        "code": "if (EventRegistry.instance) {\n  return EventRegistry.instance;\n}"
      },
      {
        "title": "Listeners condivisi",
        "description": "Tutti gli eventi registrati centralmente",
        "code": "this.listeners = {};\nEventRegistry.instance = this;"
      },
      {
        "title": "Pub/Sub globale",
        "description": "Comunicazione tra componenti disaccoppiati",
        "code": "events.on('userLogin', callback);\nevents.emit('userLogin', data);"
      }
    ],
    "solutionAdvantages": [
      "Decoupling componenti",
      "comunicazione asincrona",
      "debugging facilitato."
    ]
  },
  {
    "id": "creational-11",
    "title": "Configuratore PC",
    "category": "creational",
    "code": "// Oggetto da costruire\nclass Computer {\n  constructor() {\n    this.cpu = null;\n    this.ram = null;\n    this.gpu = null;\n  }\n}\n\n// Builder - costruisce passo dopo passo\nclass PCBuilder {\n  constructor() {\n    this.pc = new Computer();\n  }\n\n  addCPU(cpu) {\n    this.pc.cpu = cpu;\n    return this; // Permette chaining\n  }\n\n  addRAM(ram) {\n    this.pc.ram = ram;\n    return this;\n  }\n\n  addGPU(gpu) {\n    this.pc.gpu = gpu;\n    return this;\n  }\n\n  build() {\n    return this.pc;\n  }\n}\n\nconst gaming = new PCBuilder()\n  .addCPU('i9')\n  .addRAM('32GB')\n  .addGPU('RTX 4090')\n  .build();",
    "solutionExplanation": "Il <strong>Builder</strong> costruisce oggetti complessi passo dopo passo",
    "solutionPatterns": [
      "Builder"
    ],
    "solutionSteps": [
      {
        "title": "Oggetto vuoto",
        "description": "L'oggetto finale ha proprietÃ  inizialmente vuote",
        "code": "class Computer {\n  constructor() {\n    this.cpu = null;\n    this.ram = null;\n    this.gpu = null;\n  }\n}"
      },
      {
        "title": "Metodi fluenti (return this)",
        "description": "Ogni metodo imposta una proprietÃ  e restituisce il builder stesso",
        "code": "addCPU(cpu) {\n  this.pc.cpu = cpu;\n  return this; // Abilita chaining\n}"
      },
      {
        "title": "Costruzione fluida",
        "description": "Chaining method leggibile e auto-documentante",
        "code": "new PCBuilder()\n  .addCPU('i9')\n  .addRAM('32GB')\n  .addGPU('RTX 4090')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Evita costruttori con troppi parametri",
      "codice leggibile",
      "configurazioni personalizzabili",
      "validazioni intermedie possibili."
    ]
  },
  {
    "id": "creational-12",
    "title": "Email builder",
    "category": "creational",
    "code": "// Email da costruire\nclass Email {\n  constructor() {\n    this.to = [];\n    this.subject = '';\n    this.body = '';\n  }\n}\n\n// Builder per email\nclass EmailBuilder {\n  constructor() {\n    this.email = new Email();\n  }\n\n  setRecipients(to) {\n    this.email.to = to;\n    return this;\n  }\n\n  setSubject(subject) {\n    this.email.subject = subject;\n    return this;\n  }\n\n  setBody(body) {\n    this.email.body = body;\n    return this;\n  }\n\n  build() {\n    return this.email;\n  }\n}\n\nconst email = new EmailBuilder()\n  .setRecipients(['user@example.com'])\n  .setSubject('Benvenuto')\n  .setBody('Grazie!')\n  .build();",
    "solutionExplanation": "Il <strong>Builder</strong> compone email complesse gradualmente",
    "solutionPatterns": [
      "Builder"
    ],
    "solutionSteps": [
      {
        "title": "Oggetto email vuoto",
        "description": "Email inizia senza contenuto",
        "code": "class Email {\n  constructor() { this.to = []; this.subject = ''; this.body = ''; }\n}"
      },
      {
        "title": "Builder methods",
        "description": "Ogni metodo configura una parte dell'email",
        "code": "setSubject(subject) {\n  this.email.subject = subject;\n  return this;\n}"
      },
      {
        "title": "Composizione",
        "description": "Costruzione step-by-step leggibile",
        "code": "new EmailBuilder()\n  .setRecipients(['user@example.com'])\n  .setSubject('Benvenuto')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Validazione incrementale",
      "email complesse gestibili",
      "codice auto-documentante."
    ]
  },
  {
    "id": "creational-13",
    "title": "Query builder",
    "category": "creational",
    "code": "// Query SQL\nclass Query {\n  constructor() {\n    this.select = [];\n    this.from = '';\n    this.where = [];\n  }\n}\n\n// Builder per query\nclass QueryBuilder {\n  constructor() {\n    this.query = new Query();\n  }\n\n  select(...fields) {\n    this.query.select = fields;\n    return this;\n  }\n\n  from(table) {\n    this.query.from = table;\n    return this;\n  }\n\n  where(condition) {\n    this.query.where.push(condition);\n    return this;\n  }\n\n  build() {\n    return `SELECT ${this.query.select.join(', ')} FROM ${this.query.from} WHERE ${this.query.where.join(' AND ')}`;\n  }\n}\n\nconst sql = new QueryBuilder()\n  .select('id', 'name')\n  .from('users')\n  .where('active = 1')\n  .build();",
    "solutionExplanation": "Il <strong>Builder</strong> genera query sql complesse",
    "solutionPatterns": [
      "Builder"
    ],
    "solutionSteps": [
      {
        "title": "Query vuota",
        "description": "Struttura query inizialmente vuota",
        "code": "class Query {\n  constructor() { this.select = []; this.from = ''; this.where = []; }\n}"
      },
      {
        "title": "Metodi di composizione",
        "description": "Aggiunge clausole alla query",
        "code": "select(...fields) {\n  this.query.select = fields;\n  return this;\n}"
      },
      {
        "title": "Build finale",
        "description": "Compone la stringa SQL finale",
        "code": "new QueryBuilder()\n  .select('id', 'name')\n  .from('users')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Previene SQL injection",
      "sintassi corretta garantita",
      "manutenibilitÃ  alta."
    ]
  },
  {
    "id": "creational-14",
    "title": "Form builder",
    "category": "creational",
    "code": "// Form dinamico\nclass Form {\n  constructor() {\n    this.fields = [];\n    this.title = '';\n  }\n}\n\n// Builder per form\nclass FormBuilder {\n  constructor() {\n    this.form = new Form();\n  }\n\n  setTitle(title) {\n    this.form.title = title;\n    return this;\n  }\n\n  addField(type, name) {\n    this.form.fields.push({ type, name });\n    return this;\n  }\n\n  build() {\n    return this.form;\n  }\n}\n\nconst form = new FormBuilder()\n  .setTitle('Registrazione')\n  .addField('text', 'name')\n  .addField('email', 'email')\n  .addField('password', 'password')\n  .build();",
    "solutionExplanation": "Il <strong>Builder</strong> costruisce form dinamici",
    "solutionPatterns": [
      "Builder"
    ],
    "solutionSteps": [
      {
        "title": "Form vuoto",
        "description": "Form senza campi inizialmente",
        "code": "class Form {\n  constructor() { this.fields = []; this.title = ''; }\n}"
      },
      {
        "title": "Aggiunta campi",
        "description": "Aggiunge campi uno alla volta",
        "code": "addField(type, name) {\n  this.form.fields.push({ type, name });\n  return this;\n}"
      },
      {
        "title": "Form completo",
        "description": "Form configurato dinamicamente",
        "code": "new FormBuilder()\n  .setTitle('Registrazione')\n  .addField('email', 'email')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Form dinamici",
      "validazione per campo",
      "configurazione flessibile."
    ]
  },
  {
    "id": "creational-15",
    "title": "HTTP request builder",
    "category": "creational",
    "code": "// Request HTTP\nclass Request {\n  constructor() {\n    this.url = '';\n    this.method = 'GET';\n    this.headers = {};\n  }\n}\n\n// Builder per request\nclass RequestBuilder {\n  constructor() {\n    this.request = new Request();\n  }\n\n  setUrl(url) {\n    this.request.url = url;\n    return this;\n  }\n\n  setMethod(method) {\n    this.request.method = method;\n    return this;\n  }\n\n  addHeader(key, value) {\n    this.request.headers[key] = value;\n    return this;\n  }\n\n  build() {\n    return this.request;\n  }\n}\n\nconst req = new RequestBuilder()\n  .setUrl('/api/users')\n  .setMethod('POST')\n  .addHeader('Authorization', 'Bearer token')\n  .build();",
    "solutionExplanation": "Il <strong>Builder</strong> compone richieste http",
    "solutionPatterns": [
      "Builder"
    ],
    "solutionSteps": [
      {
        "title": "Request vuota",
        "description": "Configurazione request base",
        "code": "class Request {\n  constructor() { this.url = ''; this.method = 'GET'; }\n}"
      },
      {
        "title": "Configurazione",
        "description": "Imposta metodo, URL, headers",
        "code": "setMethod(method) {\n  this.request.method = method;\n  return this;\n}"
      },
      {
        "title": "Request completa",
        "description": "Request configurata e pronta",
        "code": "new RequestBuilder()\n  .setUrl('/api/users')\n  .setMethod('POST')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "API client configurabile",
      "headers centralizzati",
      "testing facilitato."
    ]
  },
  {
    "id": "creational-16",
    "title": "Template documento",
    "category": "creational",
    "code": "// Documento clonabile\nclass DocumentTemplate {\n  constructor(title, header, footer) {\n    this.title = title;\n    this.header = header;\n    this.footer = footer;\n  }\n\n  clone() {\n    return new DocumentTemplate(\n      this.title,\n      this.header,\n      this.footer\n    );\n  }\n}\n\nconst template = new DocumentTemplate(\n  'Report',\n  'Azienda S.p.A.',\n  'Â© 2025'\n);\n\nconst doc1 = template.clone();\ndoc1.title = 'Report Q1';\n\nconst doc2 = template.clone();\ndoc2.title = 'Report Q2';",
    "solutionExplanation": "Il <strong>Prototype</strong> clona oggetti invece di crearli da zero",
    "solutionPatterns": [
      "Prototype"
    ],
    "solutionSteps": [
      {
        "title": "Prototipo base",
        "description": "Template con header/footer comuni",
        "code": "const template = new DocumentTemplate(\n  'Report', 'Azienda S.p.A.', 'Â© 2025'\n);"
      },
      {
        "title": "Metodo clone",
        "description": "Copia tutte le proprietÃ ",
        "code": "clone() {\n  return new DocumentTemplate(this.title, this.header, this.footer);\n}"
      },
      {
        "title": "Personalizzazione",
        "description": "Ogni clone Ã¨ indipendente",
        "code": "const doc1 = template.clone();\ndoc1.title = 'Report Q1';"
      }
    ],
    "solutionAdvantages": [
      "Evita reinizializzazioni",
      "template riutilizzabili",
      "performance migliori."
    ]
  },
  {
    "id": "creational-17",
    "title": "Clonazione configurazioni",
    "category": "creational",
    "code": "// Configurazione clonabile\nclass ServerConfig {\n  constructor(name, port, env) {\n    this.name = name;\n    this.port = port;\n    this.env = env;\n  }\n\n  clone() {\n    return new ServerConfig(\n      this.name + '-copy',\n      this.port + 1,\n      { ...this.env }\n    );\n  }\n}\n\nconst prod = new ServerConfig('api', 3000, {\n  NODE_ENV: 'production'\n});\n\nconst staging = prod.clone();\nstaging.name = 'api-staging';\nstaging.env.NODE_ENV = 'staging';",
    "solutionExplanation": "Il <strong>Prototype</strong> duplica configurazioni server",
    "solutionPatterns": [
      "Prototype"
    ],
    "solutionSteps": [
      {
        "title": "Config base",
        "description": "Configurazione production",
        "code": "const prod = new ServerConfig('api', 3000, {\n  NODE_ENV: 'production'\n});"
      },
      {
        "title": "Clonazione",
        "description": "Incrementa porta automaticamente",
        "code": "clone() {\n  return new ServerConfig(\n    this.name + '-copy',\n    this.port + 1,\n    { ...this.env }\n  );\n}"
      },
      {
        "title": "Personalizzazione",
        "description": "Adatta per ambiente diverso",
        "code": "const staging = prod.clone();\nstaging.env.NODE_ENV = 'staging';"
      }
    ],
    "solutionAdvantages": [
      "Setup rapido ambienti",
      "consistenza config",
      "scaling semplificato."
    ]
  },
  {
    "id": "creational-18",
    "title": "Template messaggi",
    "category": "creational",
    "code": "// Messaggio clonabile\nclass Message {\n  constructor(subject, body) {\n    this.subject = subject;\n    this.body = body;\n    this.timestamp = new Date();\n  }\n\n  clone() {\n    const copy = new Message(this.subject, this.body);\n    return copy;\n  }\n}\n\nconst welcomeTemplate = new Message(\n  'Benvenuto!',\n  'Grazie per esserti iscritto.'\n);\n\nconst msg1 = welcomeTemplate.clone();\nconst msg2 = welcomeTemplate.clone();",
    "solutionExplanation": "Il <strong>Prototype</strong> clona template messaggi",
    "solutionPatterns": [
      "Prototype"
    ],
    "solutionSteps": [
      {
        "title": "Template base",
        "description": "Messaggio standard predefinito",
        "code": "const welcomeTemplate = new Message(\n  'Benvenuto!',\n  'Grazie per esserti iscritto.'\n);"
      },
      {
        "title": "Clone method",
        "description": "Crea nuova istanza con stesso contenuto",
        "code": "clone() {\n  const copy = new Message(this.subject, this.body);\n  return copy;"
      },
      {
        "title": "Utilizzo",
        "description": "Ogni messaggio ha timestamp unico",
        "code": "const msg1 = welcomeTemplate.clone();\nconst msg2 = welcomeTemplate.clone();"
      }
    ],
    "solutionAdvantages": [
      "Email transazionali",
      "branding consistente",
      "performance migliorate."
    ]
  },
  {
    "id": "creational-19",
    "title": "Test fixtures",
    "category": "creational",
    "code": "// Fixture di test\nclass TestUser {\n  constructor(id, name, role) {\n    this.id = id;\n    this.name = name;\n    this.role = role;\n  }\n\n  clone() {\n    return new TestUser(\n      this.id + 1,\n      this.name,\n      this.role\n    );\n  }\n}\n\nconst adminTemplate = new TestUser(1, 'Admin', 'admin');\nconst userTemplate = new TestUser(100, 'User', 'user');\n\nconst admin1 = adminTemplate.clone();\nconst admin2 = adminTemplate.clone();\nconst user1 = userTemplate.clone();",
    "solutionExplanation": "Il <strong>Prototype</strong> genera dati di test",
    "solutionPatterns": [
      "Prototype"
    ],
    "solutionSteps": [
      {
        "title": "Template test",
        "description": "Fixture base per admin e user",
        "code": "const adminTemplate = new TestUser(1, 'Admin', 'admin');\nconst userTemplate = new TestUser(100, 'User', 'user');"
      },
      {
        "title": "Auto-increment",
        "description": "ID incrementato automaticamente",
        "code": "clone() {\n  return new TestUser(this.id + 1, this.name, this.role);\n}"
      },
      {
        "title": "Test data",
        "description": "Genera rapidamente dati consistenti",
        "code": "const admin1 = adminTemplate.clone();\nconst admin2 = adminTemplate.clone();"
      }
    ],
    "solutionAdvantages": [
      "Test veloci",
      "dati consistenti",
      "setup semplificato."
    ]
  },
  {
    "id": "creational-20",
    "title": "Progetti duplicati",
    "category": "creational",
    "code": "// Progetto clonabile\nclass Project {\n  constructor(name, settings) {\n    this.name = name;\n    this.settings = settings;\n    this.tasks = [];\n  }\n\n  clone() {\n    const copy = new Project(\n      this.name + ' (copia)',\n      { ...this.settings }\n    );\n    copy.tasks = [...this.tasks];\n    return copy;\n  }\n}\n\nconst template = new Project('Base', { theme: 'light' });\ntemplate.tasks = ['Setup', 'Build'];\n\nconst project1 = template.clone();\nproject1.name = 'Cliente A';",
    "solutionExplanation": "Il <strong>Prototype</strong> duplica progetti complessi",
    "solutionPatterns": [
      "Prototype"
    ],
    "solutionSteps": [
      {
        "title": "Template progetto",
        "description": "Progetto con config e task standard",
        "code": "const template = new Project('Base', { theme: 'light' });\ntemplate.tasks = ['Setup', 'Build'];"
      },
      {
        "title": "Deep clone",
        "description": "Clona settings e tasks",
        "code": "clone() {\n  const copy = new Project(this.name + ' (copia)', { ...this.settings });\n  copy.tasks = [...this.tasks];\n}"
      },
      {
        "title": "Personalizzazione",
        "description": "Parte dal template ma Ã¨ indipendente",
        "code": "const project1 = template.clone();\nproject1.name = 'Cliente A';"
      }
    ],
    "solutionAdvantages": [
      "Setup rapido progetti",
      "consistenza garantita",
      "errori ridotti."
    ]
  },
  {
    "id": "creational-21",
    "title": "Tema UI",
    "category": "creational",
    "code": "// Famiglia Light\nclass LightTheme {\n  createButton() {\n    return { render: () => '<button>Light</button>' };\n  }\n  \n  createInput() {\n    return { render: () => '<input class=\"light\">' };\n  }\n}\n\n// Famiglia Dark\nclass DarkTheme {\n  createButton() {\n    return { render: () => '<button class=\"dark\">Dark</button>' };\n  }\n  \n  createInput() {\n    return { render: () => '<input class=\"dark\">' };\n  }\n}\n\nfunction getTheme(type) {\n  return type === 'dark' ? new DarkTheme() : new LightTheme();\n}\n\nconst theme = getTheme('dark');\nconst btn = theme.createButton();\nconst input = theme.createInput();",
    "solutionExplanation": "Il <strong>Abstract Factory</strong> crea famiglie di componenti ui",
    "solutionPatterns": [
      "Abstract Factory"
    ],
    "solutionSteps": [
      {
        "title": "Factory per famiglia",
        "description": "Ogni tema ha i suoi componenti",
        "code": "class LightTheme {\n  createButton() {...}\n  createInput() {...}\n}"
      },
      {
        "title": "Selezione",
        "description": "Sceglie la famiglia di componenti",
        "code": "function getTheme(type) {\n  return type === 'dark' ? new DarkTheme() : new LightTheme();\n}"
      },
      {
        "title": "Coerenza",
        "description": "Tutti i componenti sono della stessa famiglia",
        "code": "const theme = getTheme('dark');\nconst btn = theme.createButton();\nconst input = theme.createInput();"
      }
    ],
    "solutionAdvantages": [
      "Coerenza visiva",
      "cambio tema facile",
      "no mix inconsistenti."
    ]
  },
  {
    "id": "creational-22",
    "title": "Componenti piattaforma",
    "category": "creational",
    "code": "// Componenti Windows\nclass WindowsButton {\n  render() { return 'Windows Button'; }\n}\n\nclass WindowsCheckbox {\n  render() { return 'Windows Checkbox'; }\n}\n\n// Componenti Mac\nclass MacButton {\n  render() { return 'Mac Button'; }\n}\n\nclass MacCheckbox {\n  render() { return 'Mac Checkbox'; }\n}\n\n// Factory per OS\nclass WindowsFactory {\n  createButton() { return new WindowsButton(); }\n  createCheckbox() { return new WindowsCheckbox(); }\n}\n\nclass MacFactory {\n  createButton() { return new MacButton(); }\n  createCheckbox() { return new MacCheckbox(); }\n}\n\nconst factory = new WindowsFactory();\nconst btn = factory.createButton();",
    "solutionExplanation": "Il <strong>Abstract Factory</strong> componenti specifici per os",
    "solutionPatterns": [
      "Abstract Factory"
    ],
    "solutionSteps": [
      {
        "title": "Componenti per OS",
        "description": "Implementazioni native per ogni OS",
        "code": "class WindowsButton { render() { return 'Windows Button'; } }\nclass MacButton { render() { return 'Mac Button'; } }"
      },
      {
        "title": "Factory per OS",
        "description": "Crea componenti nativi dell'OS",
        "code": "class WindowsFactory {\n  createButton() { return new WindowsButton(); }\n}"
      },
      {
        "title": "UI nativa",
        "description": "Look & feel nativo garantito",
        "code": "const factory = new WindowsFactory();\nconst btn = factory.createButton();"
      }
    ],
    "solutionAdvantages": [
      "Cross-platform UI",
      "consistenza per OS",
      "manutenzione semplificata."
    ]
  },
  {
    "id": "creational-23",
    "title": "Mobili stile",
    "category": "creational",
    "code": "// Mobili moderni\nclass ModernChair {\n  sit() { return 'Sedia moderna'; }\n}\n\nclass ModernTable {\n  use() { return 'Tavolo moderno'; }\n}\n\n// Mobili vittoriani\nclass VictorianChair {\n  sit() { return 'Sedia vittoriana'; }\n}\n\nclass VictorianTable {\n  use() { return 'Tavolo vittoriano'; }\n}\n\n// Factory per stile\nclass ModernFactory {\n  createChair() { return new ModernChair(); }\n  createTable() { return new ModernTable(); }\n}\n\nclass VictorianFactory {\n  createChair() { return new VictorianChair(); }\n  createTable() { return new VictorianTable(); }\n}\n\nconst factory = new ModernFactory();\nconst chair = factory.createChair();\nconst table = factory.createTable();",
    "solutionExplanation": "Il <strong>Abstract Factory</strong> arredamento coerente",
    "solutionPatterns": [
      "Abstract Factory"
    ],
    "solutionSteps": [
      {
        "title": "Mobili per stile",
        "description": "Ogni stile ha le sue classi",
        "code": "class ModernChair { sit() { return 'Sedia moderna'; } }\nclass VictorianChair { sit() { return 'Sedia vittoriana'; } }"
      },
      {
        "title": "Factory stile",
        "description": "Crea solo mobili dello stesso stile",
        "code": "class ModernFactory {\n  createChair() { return new ModernChair(); }\n  createTable() { return new ModernTable(); }\n}"
      },
      {
        "title": "Coerenza stilistica",
        "description": "Tutti i mobili sono coerenti",
        "code": "const factory = new ModernFactory();\nconst chair = factory.createChair();\nconst table = factory.createTable();"
      }
    ],
    "solutionAdvantages": [
      "Previene mix inconsistenti",
      "cambio stile facile",
      "integritÃ  estetica."
    ]
  },
  {
    "id": "creational-24",
    "title": "Database provider",
    "category": "creational",
    "code": "// Provider MySQL\nclass MySQLConnection {\n  connect() { return 'MySQL connected'; }\n}\n\nclass MySQLQuery {\n  execute(sql) { return `MySQL: ${sql}`; }\n}\n\n// Provider PostgreSQL\nclass PostgreSQLConnection {\n  connect() { return 'PostgreSQL connected'; }\n}\n\nclass PostgreSQLQuery {\n  execute(sql) { return `PostgreSQL: ${sql}`; }\n}\n\n// Factory per DB\nclass MySQLFactory {\n  createConnection() { return new MySQLConnection(); }\n  createQuery() { return new MySQLQuery(); }\n}\n\nclass PostgreSQLFactory {\n  createConnection() { return new PostgreSQLConnection(); }\n  createQuery() { return new PostgreSQLQuery(); }\n}\n\nconst factory = new PostgreSQLFactory();\nconst conn = factory.createConnection();\nconst query = factory.createQuery();",
    "solutionExplanation": "Il <strong>Abstract Factory</strong> multi-database support",
    "solutionPatterns": [
      "Abstract Factory"
    ],
    "solutionSteps": [
      {
        "title": "Componenti DB",
        "description": "Implementazioni specifiche per ogni DB",
        "code": "class MySQLConnection { connect() {...} }\nclass MySQLQuery { execute(sql) {...} }"
      },
      {
        "title": "Factory DB",
        "description": "Crea componenti compatibili tra loro",
        "code": "class MySQLFactory {\n  createConnection() { return new MySQLConnection(); }\n  createQuery() { return new MySQLQuery(); }\n}"
      },
      {
        "title": "Switch trasparente",
        "description": "Cambio DB senza modificare codice client",
        "code": "const factory = new PostgreSQLFactory();\nconst conn = factory.createConnection();"
      }
    ],
    "solutionAdvantages": [
      "Multi-DB strategy",
      "vendor independence",
      "testing semplificato."
    ]
  },
  {
    "id": "creational-25",
    "title": "UI framework",
    "category": "creational",
    "code": "// React components\nclass ReactButton {\n  render() { return '<ReactButton />'; }\n}\n\nclass ReactInput {\n  render() { return '<ReactInput />'; }\n}\n\n// Vue components\nclass VueButton {\n  render() { return '<VueButton />'; }\n}\n\nclass VueInput {\n  render() { return '<VueInput />'; }\n}\n\n// Factory per framework\nclass ReactFactory {\n  createButton() { return new ReactButton(); }\n  createInput() { return new ReactInput(); }\n}\n\nclass VueFactory {\n  createButton() { return new VueButton(); }\n  createInput() { return new VueInput(); }\n}\n\nconst factory = new ReactFactory();\nconst btn = factory.createButton();\nconst input = factory.createInput();",
    "solutionExplanation": "Il <strong>Abstract Factory</strong> framework-agnostic components",
    "solutionPatterns": [
      "Abstract Factory"
    ],
    "solutionSteps": [
      {
        "title": "Componenti framework",
        "description": "Implementazioni per ogni framework",
        "code": "class ReactButton { render() { return '<ReactButton />'; } }\nclass VueButton { render() { return '<VueButton />'; } }"
      },
      {
        "title": "Factory framework",
        "description": "Crea componenti dello stesso framework",
        "code": "class ReactFactory {\n  createButton() { return new ReactButton(); }\n  createInput() { return new ReactInput(); }\n}"
      },
      {
        "title": "Framework consistency",
        "description": "Tutti i componenti usano React",
        "code": "const factory = new ReactFactory();\nconst btn = factory.createButton();"
      }
    ],
    "solutionAdvantages": [
      "Framework switch facile",
      "componenti compatibili",
      "architettura pulita."
    ]
  },
  {
    "id": "creational-26",
    "title": "Database connection manager",
    "category": "creational",
    "code": "// Singleton + Factory Method\nclass DatabaseManager {\n  constructor() {\n    if (DatabaseManager.instance) {\n      return DatabaseManager.instance;\n    }\n    this.connections = new Map();\n    DatabaseManager.instance = this;\n  }\n\n  getConnection(type) {\n    if (this.connections.has(type)) {\n      return this.connections.get(type);\n    }\n    \n    const conn = this.createConnection(type);\n    this.connections.set(type, conn);\n    return conn;\n  }\n\n  createConnection(type) {\n    if (type === 'mysql') {\n      return { db: 'MySQL', query: (sql) => `MySQL: ${sql}` };\n    }\n    if (type === 'postgres') {\n      return { db: 'PostgreSQL', query: (sql) => `Postgres: ${sql}` };\n    }\n    throw new Error('Unknown database type');\n  }\n}\n\nconst db1 = new DatabaseManager();\nconst db2 = new DatabaseManager();\nconsole.log(db1 === db2); // true\n\nconst mysql = db1.getConnection('mysql');\nconsole.log(mysql.query('SELECT * FROM users'));",
    "solutionPatterns": ["Singleton", "Factory Method"],
    "solutionExplanation": "Combina <strong>Singleton</strong> (unica istanza di DatabaseManager condivisa) e <strong>Factory Method</strong> (createConnection crea connessioni diverse in base al tipo). Garantisce gestione centralizzata con pool di connessioni tipizzate.",
    "solutionSteps": [
      {
        "title": "Singleton instance",
        "description": "DatabaseManager controlla e restituisce istanza esistente",
        "code": "if (DatabaseManager.instance) {\n  return DatabaseManager.instance;\n}\nDatabaseManager.instance = this;"
      },
      {
        "title": "Factory per connessioni",
        "description": "createConnection sceglie database in base al tipo",
        "code": "createConnection(type) {\n  if (type === 'mysql') return { db: 'MySQL', ... };\n  if (type === 'postgres') return { db: 'PostgreSQL', ... };\n}"
      },
      {
        "title": "Connection pooling",
        "description": "getConnection riusa connessioni esistenti",
        "code": "const mysql = db1.getConnection('mysql');\nconst pg = db1.getConnection('postgres');"
      }
    ],
    "solutionAdvantages": [
      "Manager centralizzato per tutte le connessioni",
      "Pool automatico evita duplicati",
      "Supporto multi-database flessibile"
    ]
  },
  {
    "id": "creational-27",
    "title": "User profile configurator",
    "category": "creational",
    "code": "// Builder + Prototype\nclass UserProfile {\n  constructor(data = {}) {\n    this.name = data.name || '';\n    this.email = data.email || '';\n    this.role = data.role || 'guest';\n    this.permissions = data.permissions || [];\n    this.settings = data.settings || {};\n  }\n\n  clone() {\n    return new UserProfile({\n      name: this.name,\n      email: this.email,\n      role: this.role,\n      permissions: [...this.permissions],\n      settings: { ...this.settings }\n    });\n  }\n}\n\nclass UserProfileBuilder {\n  constructor(prototype = null) {\n    this.profile = prototype ? prototype.clone() : new UserProfile();\n  }\n\n  setName(name) {\n    this.profile.name = name;\n    return this;\n  }\n\n  setEmail(email) {\n    this.profile.email = email;\n    return this;\n  }\n\n  setRole(role) {\n    this.profile.role = role;\n    return this;\n  }\n\n  addPermission(permission) {\n    this.profile.permissions.push(permission);\n    return this;\n  }\n\n  build() {\n    return this.profile;\n  }\n}\n\nconst adminTemplate = new UserProfile({ role: 'admin', permissions: ['read', 'write', 'delete'] });\n\nconst user1 = new UserProfileBuilder(adminTemplate)\n  .setName('Alice')\n  .setEmail('alice@company.com')\n  .build();",
    "solutionPatterns": ["Builder", "Prototype"],
    "solutionExplanation": "Integra <strong>Builder</strong> (UserProfileBuilder costruisce profili passo dopo passo con interfaccia fluida) e <strong>Prototype</strong> (clone() crea copie di profili esistenti come template). Permette costruzione flessibile partendo da template riutilizzabili.",
    "solutionSteps": [
      {
        "title": "Prototype clone",
        "description": "UserProfile fornisce clone() per duplicazione",
        "code": "clone() {\n  return new UserProfile({\n    role: this.role,\n    permissions: [...this.permissions],\n    settings: { ...this.settings }\n  });\n}"
      },
      {
        "title": "Builder da prototype",
        "description": "Builder puÃ² iniziare da un template clonato",
        "code": "class UserProfileBuilder {\n  constructor(prototype = null) {\n    this.profile = prototype ? prototype.clone() : new UserProfile();\n  }\n}"
      },
      {
        "title": "Costruzione fluida",
        "description": "Builder personalizza template con chaining",
        "code": "const user = new UserProfileBuilder(adminTemplate)\n  .setName('Alice')\n  .setEmail('alice@company.com')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Template riutilizzabili per ruoli comuni",
      "Costruzione fluida e leggibile",
      "Evita duplicazione configurazione"
    ]
  },
  {
    "id": "creational-28",
    "title": "API client factory",
    "category": "creational",
    "code": "// Singleton + Abstract Factory\nclass APIClientFactory {\n  constructor() {\n    if (APIClientFactory.instance) {\n      return APIClientFactory.instance;\n    }\n    this.environment = 'production';\n    APIClientFactory.instance = this;\n  }\n\n  setEnvironment(env) {\n    this.environment = env;\n  }\n\n  createHttpClient() {\n    if (this.environment === 'production') {\n      return { baseURL: 'https://api.prod.com', timeout: 5000 };\n    }\n    return { baseURL: 'http://localhost:3000', timeout: 30000 };\n  }\n\n  createAuthClient() {\n    if (this.environment === 'production') {\n      return { provider: 'OAuth2', endpoint: 'https://auth.prod.com' };\n    }\n    return { provider: 'Basic', endpoint: 'http://localhost:4000' };\n  }\n\n  createStorageClient() {\n    if (this.environment === 'production') {\n      return { type: 'S3', bucket: 'prod-uploads' };\n    }\n    return { type: 'Local', path: './uploads' };\n  }\n}\n\nconst factory = new APIClientFactory();\nfactory.setEnvironment('development');\n\nconst http = factory.createHttpClient();\nconst auth = factory.createAuthClient();\nconst storage = factory.createStorageClient();\n\nconsole.log(http.baseURL); // http://localhost:3000",
    "solutionPatterns": ["Singleton", "Abstract Factory"],
    "solutionExplanation": "Combina <strong>Singleton</strong> (unica istanza di APIClientFactory) e <strong>Abstract Factory</strong> (famiglia di client correlati - HTTP, Auth, Storage - creati coerentemente per ambiente). Garantisce configurazione centralizzata con client compatibili.",
    "solutionSteps": [
      {
        "title": "Singleton factory",
        "description": "APIClientFactory Ã¨ istanza unica condivisa",
        "code": "if (APIClientFactory.instance) {\n  return APIClientFactory.instance;\n}\nAPIClientFactory.instance = this;"
      },
      {
        "title": "Abstract factory methods",
        "description": "Ogni metodo crea client diverso per ambiente",
        "code": "createHttpClient() {\n  if (this.environment === 'production') return { baseURL: 'prod' };\n  return { baseURL: 'localhost' };\n}"
      },
      {
        "title": "Famiglia coerente",
        "description": "Tutti i client sono compatibili per l'ambiente",
        "code": "factory.setEnvironment('development');\nconst http = factory.createHttpClient();\nconst auth = factory.createAuthClient();"
      }
    ],
    "solutionAdvantages": [
      "Switch ambiente centralizzato",
      "Client sempre compatibili tra loro",
      "Configurazione condivisa globalmente"
    ]
  },
  {
    "id": "creational-29",
    "title": "Document template system",
    "category": "creational",
    "code": "// Prototype + Builder\nclass Document {\n  constructor(data = {}) {\n    this.title = data.title || '';\n    this.content = data.content || '';\n    this.metadata = data.metadata || {};\n    this.styles = data.styles || {};\n  }\n\n  clone() {\n    return new Document({\n      title: this.title,\n      content: this.content,\n      metadata: { ...this.metadata },\n      styles: { ...this.styles }\n    });\n  }\n}\n\nclass DocumentBuilder {\n  constructor(template = null) {\n    this.doc = template ? template.clone() : new Document();\n  }\n\n  setTitle(title) {\n    this.doc.title = title;\n    return this;\n  }\n\n  setContent(content) {\n    this.doc.content = content;\n    return this;\n  }\n\n  addMetadata(key, value) {\n    this.doc.metadata[key] = value;\n    return this;\n  }\n\n  setStyle(property, value) {\n    this.doc.styles[property] = value;\n    return this;\n  }\n\n  build() {\n    return this.doc;\n  }\n}\n\nconst reportTemplate = new Document({\n  metadata: { type: 'report', format: 'PDF' },\n  styles: { font: 'Arial', size: 12 }\n});\n\nconst report1 = new DocumentBuilder(reportTemplate)\n  .setTitle('Q1 Sales Report')\n  .setContent('Sales data...')\n  .addMetadata('quarter', 'Q1')\n  .build();",
    "solutionPatterns": ["Prototype", "Builder"],
    "solutionExplanation": "Integra <strong>Prototype</strong> (Document.clone() duplica template esistenti) e <strong>Builder</strong> (DocumentBuilder costruisce documenti passo dopo passo). Permette creazione rapida da template con personalizzazione fluida.",
    "solutionSteps": [
      {
        "title": "Prototype template",
        "description": "Document clone() crea copia completa",
        "code": "clone() {\n  return new Document({\n    metadata: { ...this.metadata },\n    styles: { ...this.styles }\n  });\n}"
      },
      {
        "title": "Builder da template",
        "description": "Builder inizia da template clonato",
        "code": "constructor(template = null) {\n  this.doc = template ? template.clone() : new Document();\n}"
      },
      {
        "title": "Customizzazione",
        "description": "Builder personalizza template con chaining",
        "code": "new DocumentBuilder(reportTemplate)\n  .setTitle('Q1 Report')\n  .addMetadata('quarter', 'Q1')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Template riutilizzabili per tipi documento",
      "Personalizzazione rapida con builder",
      "Evita reinizializzazione metadata/styles"
    ]
  },
  {
    "id": "creational-30",
    "title": "Plugin system loader",
    "category": "creational",
    "code": "// Factory Method + Singleton\nclass PluginLoader {\n  constructor() {\n    if (PluginLoader.instance) {\n      return PluginLoader.instance;\n    }\n    this.plugins = new Map();\n    PluginLoader.instance = this;\n  }\n\n  loadPlugin(name) {\n    if (this.plugins.has(name)) {\n      return this.plugins.get(name);\n    }\n\n    const plugin = this.createPlugin(name);\n    this.plugins.set(name, plugin);\n    plugin.init();\n    return plugin;\n  }\n\n  createPlugin(name) {\n    if (name === 'analytics') {\n      return {\n        name: 'Analytics',\n        init: () => console.log('ðŸ“Š Analytics initialized'),\n        track: (event) => console.log(`Track: ${event}`)\n      };\n    }\n    if (name === 'logger') {\n      return {\n        name: 'Logger',\n        init: () => console.log('ðŸ“ Logger initialized'),\n        log: (msg) => console.log(`Log: ${msg}`)\n      };\n    }\n    throw new Error('Unknown plugin');\n  }\n}\n\nconst loader1 = new PluginLoader();\nconst loader2 = new PluginLoader();\nconsole.log(loader1 === loader2); // true\n\nconst analytics = loader1.loadPlugin('analytics');\nanalytics.track('page_view');",
    "solutionPatterns": ["Factory Method", "Singleton"],
    "solutionExplanation": "Combina <strong>Factory Method</strong> (createPlugin crea plugin diversi in base al nome) e <strong>Singleton</strong> (unica istanza di PluginLoader condivisa). Garantisce caricamento centralizzato con registry automatico dei plugin.",
    "solutionSteps": [
      {
        "title": "Singleton loader",
        "description": "PluginLoader Ã¨ istanza unica condivisa",
        "code": "if (PluginLoader.instance) {\n  return PluginLoader.instance;\n}\nPluginLoader.instance = this;"
      },
      {
        "title": "Factory creation",
        "description": "createPlugin sceglie tipo plugin in base al nome",
        "code": "createPlugin(name) {\n  if (name === 'analytics') return { name: 'Analytics', ... };\n  if (name === 'logger') return { name: 'Logger', ... };\n}"
      },
      {
        "title": "Plugin registry",
        "description": "loadPlugin carica e registra plugin una sola volta",
        "code": "loadPlugin(name) {\n  if (this.plugins.has(name)) return this.plugins.get(name);\n  const plugin = this.createPlugin(name);\n  this.plugins.set(name, plugin);\n}"
      }
    ],
    "solutionAdvantages": [
      "Loader centralizzato per tutti i plugin",
      "Registry automatico evita duplicati",
      "Lazy loading dei plugin"
    ]
  },
  {
    "id": "creational-31",
    "title": "Email template generator",
    "category": "creational",
    "code": "// Builder + Prototype\nclass EmailTemplate {\n  constructor(data = {}) {\n    this.subject = data.subject || '';\n    this.body = data.body || '';\n    this.footer = data.footer || 'Best regards';\n    this.styles = data.styles || { color: '#000', fontSize: '14px' };\n  }\n\n  clone() {\n    return new EmailTemplate({\n      subject: this.subject,\n      body: this.body,\n      footer: this.footer,\n      styles: { ...this.styles }\n    });\n  }\n}\n\nclass EmailBuilder {\n  constructor(template = null) {\n    this.email = template ? template.clone() : new EmailTemplate();\n  }\n\n  setSubject(subject) {\n    this.email.subject = subject;\n    return this;\n  }\n\n  setBody(body) {\n    this.email.body = body;\n    return this;\n  }\n\n  setFooter(footer) {\n    this.email.footer = footer;\n    return this;\n  }\n\n  setStyle(property, value) {\n    this.email.styles[property] = value;\n    return this;\n  }\n\n  build() {\n    return this.email;\n  }\n}\n\nconst corporateTemplate = new EmailTemplate({\n  footer: 'Company Inc. | All rights reserved',\n  styles: { color: '#333', fontSize: '16px', fontFamily: 'Arial' }\n});\n\nconst welcome = new EmailBuilder(corporateTemplate)\n  .setSubject('Welcome to our platform')\n  .setBody('Thank you for joining us!')\n  .build();",
    "solutionPatterns": ["Builder", "Prototype"],
    "solutionExplanation": "Integra <strong>Builder</strong> (EmailBuilder costruisce email passo dopo passo) e <strong>Prototype</strong> (EmailTemplate.clone() duplica template aziendali). Permette creazione rapida di email personalizzate da template con stili predefiniti.",
    "solutionSteps": [
      {
        "title": "Prototype template",
        "description": "EmailTemplate clone() duplica footer e styles",
        "code": "clone() {\n  return new EmailTemplate({\n    footer: this.footer,\n    styles: { ...this.styles }\n  });\n}"
      },
      {
        "title": "Builder da template",
        "description": "EmailBuilder parte da template aziendale",
        "code": "constructor(template = null) {\n  this.email = template ? template.clone() : new EmailTemplate();\n}"
      },
      {
        "title": "Personalizzazione",
        "description": "Builder customizza subject e body mantenendo stili",
        "code": "new EmailBuilder(corporateTemplate)\n  .setSubject('Welcome')\n  .setBody('Thank you!')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Template aziendali riutilizzabili",
      "Branding consistente automatico",
      "Personalizzazione rapida del contenuto"
    ]
  },
  {
    "id": "creational-32",
    "title": "Cache manager service",
    "category": "creational",
    "code": "// Singleton + Factory Method\nclass CacheManager {\n  constructor() {\n    if (CacheManager.instance) {\n      return CacheManager.instance;\n    }\n    this.caches = new Map();\n    CacheManager.instance = this;\n  }\n\n  getCache(type) {\n    if (this.caches.has(type)) {\n      return this.caches.get(type);\n    }\n\n    const cache = this.createCache(type);\n    this.caches.set(type, cache);\n    return cache;\n  }\n\n  createCache(type) {\n    if (type === 'memory') {\n      return {\n        type: 'Memory',\n        data: new Map(),\n        get: function(key) { return this.data.get(key); },\n        set: function(key, val) { this.data.set(key, val); }\n      };\n    }\n    if (type === 'redis') {\n      return {\n        type: 'Redis',\n        data: new Map(),\n        get: function(key) { console.log('Redis GET'); return this.data.get(key); },\n        set: function(key, val) { console.log('Redis SET'); this.data.set(key, val); }\n      };\n    }\n    throw new Error('Unknown cache type');\n  }\n}\n\nconst manager1 = new CacheManager();\nconst manager2 = new CacheManager();\nconsole.log(manager1 === manager2); // true\n\nconst memCache = manager1.getCache('memory');\nmemCache.set('user:1', { name: 'Alice' });\nconsole.log(memCache.get('user:1'));",
    "solutionPatterns": ["Singleton", "Factory Method"],
    "solutionExplanation": "Combina <strong>Singleton</strong> (unica istanza di CacheManager) e <strong>Factory Method</strong> (createCache crea cache diversi - memory, Redis). Garantisce gestione centralizzata con registry automatico per evitare cache duplicati.",
    "solutionSteps": [
      {
        "title": "Singleton manager",
        "description": "CacheManager Ã¨ istanza unica condivisa",
        "code": "if (CacheManager.instance) {\n  return CacheManager.instance;\n}\nCacheManager.instance = this;"
      },
      {
        "title": "Factory per cache",
        "description": "createCache crea implementazioni diverse",
        "code": "createCache(type) {\n  if (type === 'memory') return { type: 'Memory', ... };\n  if (type === 'redis') return { type: 'Redis', ... };\n}"
      },
      {
        "title": "Cache registry",
        "description": "getCache riusa cache esistenti",
        "code": "const memCache = manager.getCache('memory');\nconst redisCache = manager.getCache('redis');"
      }
    ],
    "solutionAdvantages": [
      "Manager centralizzato multi-cache",
      "Registry evita istanze duplicate",
      "Switch cache type trasparente"
    ]
  },
  {
    "id": "creational-33",
    "title": "Test fixture builder",
    "category": "creational",
    "code": "// Prototype + Builder\nclass TestFixture {\n  constructor(data = {}) {\n    this.name = data.name || '';\n    this.setup = data.setup || [];\n    this.teardown = data.teardown || [];\n    this.mocks = data.mocks || {};\n  }\n\n  clone() {\n    return new TestFixture({\n      name: this.name,\n      setup: [...this.setup],\n      teardown: [...this.teardown],\n      mocks: { ...this.mocks }\n    });\n  }\n}\n\nclass FixtureBuilder {\n  constructor(prototype = null) {\n    this.fixture = prototype ? prototype.clone() : new TestFixture();\n  }\n\n  setName(name) {\n    this.fixture.name = name;\n    return this;\n  }\n\n  addSetup(step) {\n    this.fixture.setup.push(step);\n    return this;\n  }\n\n  addTeardown(step) {\n    this.fixture.teardown.push(step);\n    return this;\n  }\n\n  addMock(name, mock) {\n    this.fixture.mocks[name] = mock;\n    return this;\n  }\n\n  build() {\n    return this.fixture;\n  }\n}\n\nconst dbFixture = new TestFixture({\n  setup: ['connectDB', 'seedData'],\n  teardown: ['clearDB', 'disconnectDB'],\n  mocks: { db: 'mockDB' }\n});\n\nconst userTest = new FixtureBuilder(dbFixture)\n  .setName('User API Test')\n  .addMock('userService', 'mockUserService')\n  .build();",
    "solutionPatterns": ["Prototype", "Builder"],
    "solutionExplanation": "Integra <strong>Prototype</strong> (TestFixture.clone() duplica setup/teardown comuni) e <strong>Builder</strong> (FixtureBuilder costruisce test fixture con chaining). Evita duplicazione di setup DB comuni con personalizzazione per test specifici.",
    "solutionSteps": [
      {
        "title": "Prototype fixture",
        "description": "TestFixture clone() duplica setup/teardown/mocks",
        "code": "clone() {\n  return new TestFixture({\n    setup: [...this.setup],\n    teardown: [...this.teardown],\n    mocks: { ...this.mocks }\n  });\n}"
      },
      {
        "title": "Builder da fixture",
        "description": "FixtureBuilder parte da template DB comune",
        "code": "constructor(prototype = null) {\n  this.fixture = prototype ? prototype.clone() : new TestFixture();\n}"
      },
      {
        "title": "Test customization",
        "description": "Builder aggiunge mocks specifici per test",
        "code": "new FixtureBuilder(dbFixture)\n  .setName('User API Test')\n  .addMock('userService', 'mockUserService')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Setup DB comune riutilizzabile",
      "Test fixture personalizzabili",
      "Riduce boilerplate nei test"
    ]
  },
  {
    "id": "creational-34",
    "title": "Notification service hub",
    "category": "creational",
    "code": "// Singleton + Abstract Factory\nclass NotificationHub {\n  constructor() {\n    if (NotificationHub.instance) {\n      return NotificationHub.instance;\n    }\n    this.provider = 'standard';\n    NotificationHub.instance = this;\n  }\n\n  setProvider(provider) {\n    this.provider = provider;\n  }\n\n  createEmailNotifier() {\n    if (this.provider === 'aws') {\n      return { service: 'SES', send: (to, msg) => console.log(`SES â†’ ${to}: ${msg}`) };\n    }\n    return { service: 'SMTP', send: (to, msg) => console.log(`SMTP â†’ ${to}: ${msg}`) };\n  }\n\n  createSMSNotifier() {\n    if (this.provider === 'aws') {\n      return { service: 'SNS', send: (phone, msg) => console.log(`SNS â†’ ${phone}: ${msg}`) };\n    }\n    return { service: 'Twilio', send: (phone, msg) => console.log(`Twilio â†’ ${phone}: ${msg}`) };\n  }\n\n  createPushNotifier() {\n    if (this.provider === 'aws') {\n      return { service: 'SNS Push', send: (token, msg) => console.log(`SNS Push â†’ ${token}: ${msg}`) };\n    }\n    return { service: 'Firebase', send: (token, msg) => console.log(`FCM â†’ ${token}: ${msg}`) };\n  }\n}\n\nconst hub = new NotificationHub();\nhub.setProvider('aws');\n\nconst email = hub.createEmailNotifier();\nconst sms = hub.createSMSNotifier();\nconst push = hub.createPushNotifier();\n\nemail.send('user@example.com', 'Welcome!');",
    "solutionPatterns": ["Singleton", "Abstract Factory"],
    "solutionExplanation": "Combina <strong>Singleton</strong> (unica istanza di NotificationHub) e <strong>Abstract Factory</strong> (famiglia coerente di notifier - Email, SMS, Push - per provider AWS o standard). Garantisce switch provider centralizzato con notifier compatibili.",
    "solutionSteps": [
      {
        "title": "Singleton hub",
        "description": "NotificationHub Ã¨ istanza unica condivisa",
        "code": "if (NotificationHub.instance) {\n  return NotificationHub.instance;\n}\nNotificationHub.instance = this;"
      },
      {
        "title": "Abstract factory methods",
        "description": "Ogni metodo crea notifier per provider corrente",
        "code": "createEmailNotifier() {\n  if (this.provider === 'aws') return { service: 'SES', ... };\n  return { service: 'SMTP', ... };\n}"
      },
      {
        "title": "Famiglia coerente",
        "description": "Tutti i notifier usano stesso provider",
        "code": "hub.setProvider('aws');\nconst email = hub.createEmailNotifier(); // SES\nconst sms = hub.createSMSNotifier();     // SNS"
      }
    ],
    "solutionAdvantages": [
      "Switch provider centralizzato",
      "Notifier sempre compatibili",
      "Multi-canale con coerenza garantita"
    ]
  },
  {
    "id": "creational-35",
    "title": "Configuration preset manager",
    "category": "creational",
    "code": "// Prototype + Builder\nclass ConfigPreset {\n  constructor(data = {}) {\n    this.database = data.database || {};\n    this.cache = data.cache || {};\n    this.logging = data.logging || {};\n    this.features = data.features || [];\n  }\n\n  clone() {\n    return new ConfigPreset({\n      database: { ...this.database },\n      cache: { ...this.cache },\n      logging: { ...this.logging },\n      features: [...this.features]\n    });\n  }\n}\n\nclass ConfigBuilder {\n  constructor(preset = null) {\n    this.config = preset ? preset.clone() : new ConfigPreset();\n  }\n\n  setDatabase(host, port) {\n    this.config.database = { host, port };\n    return this;\n  }\n\n  setCache(type, ttl) {\n    this.config.cache = { type, ttl };\n    return this;\n  }\n\n  setLogging(level) {\n    this.config.logging = { level };\n    return this;\n  }\n\n  addFeature(feature) {\n    this.config.features.push(feature);\n    return this;\n  }\n\n  build() {\n    return this.config;\n  }\n}\n\nconst productionPreset = new ConfigPreset({\n  database: { host: 'prod.db.com', port: 5432 },\n  cache: { type: 'redis', ttl: 3600 },\n  logging: { level: 'error' },\n  features: ['ssl', 'compression']\n});\n\nconst customConfig = new ConfigBuilder(productionPreset)\n  .setLogging('warn')\n  .addFeature('monitoring')\n  .build();",
    "solutionPatterns": ["Prototype", "Builder"],
    "solutionExplanation": "Integra <strong>Prototype</strong> (ConfigPreset.clone() duplica preset ambiente - production, development) e <strong>Builder</strong> (ConfigBuilder personalizza preset con interfaccia fluida). Permette configurazione rapida da preset con override selettivi.",
    "solutionSteps": [
      {
        "title": "Prototype preset",
        "description": "ConfigPreset clone() duplica configurazione completa",
        "code": "clone() {\n  return new ConfigPreset({\n    database: { ...this.database },\n    cache: { ...this.cache },\n    features: [...this.features]\n  });\n}"
      },
      {
        "title": "Builder da preset",
        "description": "ConfigBuilder parte da preset production/dev",
        "code": "constructor(preset = null) {\n  this.config = preset ? preset.clone() : new ConfigPreset();\n}"
      },
      {
        "title": "Override selettivo",
        "description": "Builder modifica solo proprietÃ  necessarie",
        "code": "new ConfigBuilder(productionPreset)\n  .setLogging('warn')\n  .addFeature('monitoring')\n  .build();"
      }
    ],
    "solutionAdvantages": [
      "Preset ambiente riutilizzabili",
      "Override selettivo senza ridefinire tutto",
      "Configurazione type-safe con builder"
    ]
  }
]